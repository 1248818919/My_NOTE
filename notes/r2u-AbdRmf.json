{"_id":"note:r2u-AbdRmf","title":"HiPPO","content":"# HiPPO论文笔记\n\n论文名称\n>《HiPPO: Recurrent Memory with Optimal Polynomial Projections》\n\n## 1.Motivation\n\n给定一个输入函数$f(t),t>0$，许多问题需要对累积历史进行操作$f_{\\leq}:=f(x)|_{x\\leq t}$,从而理解为了理解到目前为止看到的输入，并做出未来的预测。然而由于由于函数的空间非常大，因此不能完美地记住历史，必须压缩，所以作者的解决方案是利用近似方法，将高位空间投影到子空间中。\n\n具体地，利用拟合方法，寻找$g^{(t)} \\in \\mathcal{G}$，其中$\\mathcal{G}$表示中任意n维子空间，以最小化$||f_{\\leq t}-g^{(t)}||_{L_2(\\mu^{(t)})}$为目标.所以问题转化为如何在给定$\\mu(t)$的封闭形式下解决优化问题，以及如何在$t→∞$时在线保持这些系数。\n\n## 2.General HiPPO framework\n\n![HiPPO.model](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/HiPPO_framework.jpg?raw=true)\n\n**问题定义** 给定一个权重measure在$(-\\infty,t]上$，一个基函数的序列$\\mathcal{G}=span\\{g_{n}^{(t)}\\}_{n \\in[N]}$,一个连续函数$f:\\mathbb{R_{\\geq0}\\rightarrow \\mathbb{R}}$,HiPPO定义了一个将f映射到最优投影系数的算子$c:R_{\\geq0}\\rightarrow \\mathbb{R}^{N}$\n\n![eq1](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/eq1.jpg?raw=true)\n\n**Approximation Measures** \n\n定义密度$w(t,x):=\\frac{d\\mu^{(t)}}{d\\lambda}(x)$,其实就是理解这个东西是一个二维的，一个维度代表时间，一个维度代表我们的数据$x$。\n\n已经给定一组正交多项式$\\{ P_n \\}_{n\\in \\mathbb{N}}$,且他们的权函数是$\\mu$，如果加上时间维度的话,就是右上角有个上标$t$，我们用$p_n^{(t)}$表示经过归一化后的正交多项式，且$p_n(t,x)=p_n^{(t)}(x)$两者含义相同。\n\n对于任意 scaling function（缩放函数） $\\chi(t,x)=\\chi^{(t)}(x)$,函数$p_n(x)\\chi(x)$是正交的关于密度$w/\\chi^{2}$在任何时间t。原因如下：\n\n![img](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/approximation.jpg?raw=true)\n\n也就是说作者对于权函数$v^{(t)}$定义了一组正交基，且能够包含随意的基，并不只有OPs。\n\n**The Projection and Coefficient**\n\n在获取了正交基后，我们只需要计算$<f_{\\leq t},g_n^t>_{\\mathcal{v^{(t)}}}$的点积即可，从而获得函数f在这个空间下基的表示方法。\n\n![eq2](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/eq2.jpg?raw=true)\n\n上面这个方法被叫做HiPPO算子的投影。\n\n**Coefficient Dynamics: the hippo Operator**\n\n具体的，就是对其进行求导，然后进行分析，发现是由隐藏状态和输入组成的一个线性微分方程。\n![eq2](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/eq3.jpg?raw=true)\n\n**Discretization**\n离散的形式表达为\n\n![eq4](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/eq4.jpg?raw=true)\n![dis](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/discreation.jpg?raw=true)\n\n至于他们对于各种多项式比如勒让德多项式的具体推导，由于知识储备原因无法看懂，所以先行略过。\n\n![eq5](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/eq5.jpg?raw=true)\n\n对于作者对勒让德多项式的域转移到[0,T]上后，他们的HiPPO中相关参数如下\n\n![eq6](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/eq6.jpg?raw=true)\n\n## 3.Experiment\n\n首先，作者展示了他们如何将HIPPO融入到RNN中，在MNIST数据集上的分类情况。\n![res1](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/res1.jpg?raw=true)\n\n其次，作者展示了他们模型的泛化能力，作者使用字符轨迹数据集，其目标是从一个用户以固定采样率收集的一系列笔划测量中对字符进行分类。为了模拟时标位移(例如，在另一个手写较慢的用户上进行测试)，我们考虑了两个标准的时间序列生成过程:(1)在以固定速率采样底层序列的设置下，我们改变测试采样速率;关键是，序列是可变长度的，因此模型无法检测到数据的采样率。(2)在带有时间戳的不规则采样(或缺失)数据的设置中，对测试时间戳进行缩放。\n\n他说明模型可以通过简单地根据给定的离散步长进化来无缝地处理缺失或不规则采样的数据。\n![res2](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/res2.jpg?raw=true)\n\n在此之上，模型速度也非常快。\n![res2](https://github.com/1248818919/My_NOTE/blob/master/assets/Sequence%20Model/HiPPO/res3.jpg?raw=true)","tags":[],"folderPathname":"/Sequence Model","data":{},"createdAt":"2023-12-15T04:55:53.655Z","updatedAt":"2023-12-16T04:10:13.854Z","trashed":false,"_rev":"qkgpfpHYn"}