{"_id":"note:7QQkw7ea53","title":"DeepSort","content":"# DeepSort论文笔记\n\n## 1.Preliminary\n\n### 1.1 匈牙利算法（Hungarian Algorithm）\n\n首先，先介绍一下什么是分配问题（Assignment Problem）：假设有N个人和N个任务，每个任务可以任意分配给不同的人，已知每个人完成每个任务要花费的代价不尽相同，那么如何分配可以使得总的代价最小。\n\n匈牙利算法（又叫KM算法）就是用来解决分配问题的一种方法，它基于定理：\n\n>如果代价矩阵的某一行或某一列同时加上或减去某个数，则这个新的代价矩阵的最优分配仍然是原代价矩阵的最优分配。\n\n>证明：\n>假设存在新的代价矩阵的最优分配不是原来的代价矩阵的最优分配，则下面这种情况自相矛盾：<br>\n1.原代价矩阵的最优分配记为A1，的某一行/列加上某个数K，则新产生的代价矩阵有新的最优分配，记为A2，易得A2由于A1。<br>\n2.新代价矩阵的最优分配的再减去数K，得到原来的代价矩阵，记为A3，根据定理A3=A1优于A2<br>\n综上，结论互相矛盾，所以证明完毕。\n\n算法步骤：\n\n1.对于矩阵的每一行，减去其中最小的元素。\n\n2.对于矩阵的每一列，减去其中最小的元素。\n\n3.用最少的水平线或垂直线覆盖矩阵中所有的0。\n\n4.如果线的数量等于N，则找到了最优分配，算法结束，否则进入步骤5。\n\n5.找到没有被任何线覆盖的最小元素，每个没被线覆盖的行减去这个元素，每个被线覆盖的列加上这个元素，返回步骤3。\n\n### 1.2 卡尔曼滤波（Kalman Filter）\n\n![kalman Filter](https://github.com/1248818919/My_NOTE/blob/master/assets/Computer_Vision/SingleView/DeepSort/kilman.png?raw=true)\n\n（线性）卡尔曼滤波的应用基于以下三个假设前提：\n\n1.当前时刻状态只和上一时刻状态有关。\n\n2.模型和系统均满足线性关系。\n\n3.引入的噪声符合高斯分布。\n\n对于和多时刻状态有关、非线性、非高斯问题，将不能简单地使用卡尔曼滤波，需要做其他处理，不属于本文的范畴。\n\n基于上述假设，我们可以得到如下两个表征过程模型和测量模型的公式：\n\n$x_k=Fx_{k-1}+Bu_{k-1}+w_k$  表示过程模型\n\n$z_k=Hx_k+v_k$ 表示测量模型\n\n其中，$x_k$表示k时刻的真实值，是待估计的值；$x_{k-1}$表示k-1时刻的真实值;$u_{k-1}$表示k-1时刻的控制输入量，比如加速度之类的;$w_k$表示过程噪声，符合均值为0，协方差矩阵为Q的高斯噪声分布;$z_k$表示k时刻的观测值，例如雷达或者GPS测量结果，它可能和$x_k$保持相同维度，也可能和$x_k$不同维度，比如包括位置和速度，但测量仪器只观测位置信息，而忽略了速度信息；又例如，视觉里程计中，直接观测结果是图像像素，而状态量是位姿信息;$v_k$表示测量噪声，类似$w_k$,有$p(v_k) \\sim N(0,R)$;$F,B,H$分别表示状态转移矩阵，控制矩阵，观测转移矩阵。\n\n本文中，大写字母表示矩阵，带一维下角标的小写字母表示列向量，每个元素用带二维下角标的小写字母表示。\n\n对于测量模型，由于$w_k$、$x_{k-1}$未知，我们不妨忽略$w_k$，并假设\n    \n$x^-_k=F\\tilde{x}_{k-1}+Bu_{k-1}$\n\n我们使用上一时刻的最优估计值$\\tilde{x}_{k-1}$来替代真实值，并将$x^-_k$称为当前时刻通过过程模型得到的预测值，也叫做先验估计值。显然，这是一个误差较大的预估值，我们使用观测值来进行修正（你可能会问，如果没有测量值呢？那问题到此结束，也用不上卡尔曼滤波了，本文的背景便是通过观测值来修正预测值）。\n\n对其进行修正，从预估值角度出发\n\n对于公式测量模型，我们借鉴上述做法，同样忽略掉测量噪声$v_k$，得到\n\n$z_k=Hx^{measure}_k \\Rightarrow x^{measure}_k=H^{-1}z_k$\n\n我们通过观测值和观测矩阵获得了和预估值相同维度的$x_k^{measure}$，因此将其和x^-_{k}作差，用来修正预估值，则有\n\n$\\tilde{x}_{k}=x^-_{k}+G(x^{measure}_k-x^-_k)$ 其中G为系数矩阵，我们假设$G=KH$,K为卡尔曼增益，$\\tilde{x}_k$为最优值。\n\n$\\tilde{x}_{k}=x^-_{k}+K(z_k-Hx^-_k)$\n\n![tuidao1](https://github.com/1248818919/My_NOTE/blob/master/assets/Computer_Vision/SingleView/DeepSort/tuidao.jpg?raw=true)\n\n![tuidao2](https://github.com/1248818919/My_NOTE/blob/master/assets/Computer_Vision/SingleView/DeepSort/%E6%8E%A8%E5%AF%BC2.jpg?raw=true)\n\n![tuidao3](https://github.com/1248818919/My_NOTE/blob/master/assets/Computer_Vision/SingleView/DeepSort/%E6%8E%A8%E5%AF%BC3.jpg?raw=true)\n\n![tuidao4](https://github.com/1248818919/My_NOTE/blob/master/assets/Computer_Vision/SingleView/DeepSort/%E6%8E%A8%E5%AF%BC4.jpg?raw=true)\n\n### 3.马氏距离\n简单来说，就是担心维度间他们的分布以及量纲的不同，所以对他们进行归一化后求距离。\n\n马氏距离与源点的距离：\n\n$D_m=(x-u)\\sum^{-1}(x-u)$\n\n任意两个点之间的距离\n\n$D_m=(x-y)\\sum^{-1}(x-y)$\n\n其中，$\\sum^{-1}$表示数据集X的协方差矩阵\n\n## 2.DeepSort方法\n\nDeepSORT对每一帧的处理流程如下：检测器得到bbox → 生成detections → 卡尔曼滤波预测→ 使用匈牙利算法将预测后的tracks和当前帧中的detecions进行匹配（级联匹配和IOU匹配） → 卡尔曼滤波更新\n\n### 2.1 卡尔曼滤波\n\n在DeepSort中，使用的状态是一个八元组，$(u,v,\\gamma,h,\\dot{x},\\dot{y},\\dot{\\gamma},\\dot{h})$,其中$(u,v)$是bounding box的中心坐标，$r$是长宽比，$h$表示高度。其余四个变量表示对应的在图像坐标系中的速度信息。\n\n目标的创建与移除\n对每一个追踪目标，记录自其上一次检测结果与追踪结果匹配之后的帧数{a_k}，一旦一个目标的检测结果与追踪结果正确关联之后，就将该参数设置为0。如果$a_k$超过了设置的最大阈值$A_{max}$ ，则认为对该目标的追踪过程已结束。对新目标出现的判断则是，如果某次检测结果中的某个目标始终无法与已经存在的追踪器进行关联，那么则认为可能出现了新目标。如果连续的3帧中潜在的新的追踪器对目标位置的预测结果都能够与检测结果正确关联，那么则确认是出现了新的运动目标；如果不能达到该要求，则认为是出现了“虚警”，需要删除该运动目标。\n\n### 2.2 指派问题\n\n#### Motion Information\n\n使用了对已存在的运动目标的运动状态的kalman预测结果与检测结果之间的马氏距离进行运行信息的关联，公式如下：\n\n$d^{1}(i,j)=(d_j-y_i)^TS_i^{-1}(d_j-y_i)$ （马氏距离）\n\n{d_j}表示第j个检测框的位置，{y_i}表示第i个追踪器对目标的预测位置，$S_i$表示检测位置与平均追踪位置之间的协方差矩阵。如果某次关联的马氏距离小于指定的阈值，值为1，否则为0，记为$b^{(1)}_{i,j}$\n\n当运动的不确定性很低的时候，上述的马氏距离匹配是一个合适的关联度量方法，但是在图像空间中使用kalman滤波进行运动状态估计只是一个比较粗糙的预测。特别是相机存在运动时会使得马氏距离的关联方法失效，造成出现ID switch的现象。因此作者引入了第二种关联方法，对每一个的检测块$d_j$求一个特征向量$r_j$(利用CNN求，下图所示),限制条件是$||r_i||=1$，作者对每一个追踪目标构建一个gallary，存储每一个追踪目标成功关联的最近100帧的特征向量。那么第二种度量方式就是计算第i个追踪器的最近100个成功关联的特征集与当前帧第j个检测结果的特征向量间的最小余弦距离。计算公式为：\n\n$d^{(2)}(i,j)=min(1-r_j^Tr_k^{i} | r_k^{i} \\in R_i)$","tags":[],"folderPathname":"/Computer Vision/Track/single_view","data":{},"createdAt":"2023-11-30T03:10:52.497Z","updatedAt":"2023-11-30T14:35:49.071Z","trashed":false,"_rev":"iwbb9X-vh"}